name: CI

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Set DBT_PROFILES_DIR
        run: echo "DBT_PROFILES_DIR=${{ github.workspace }}/dbt" >> $GITHUB_ENV

      - name: Prepare DuckDB path
        run: mkdir -p db

      - name: dbt parse
        run: dbt parse

      - name: dbt compile
        run: dbt compile

      - name: Create sample raw Parquet
        run: |
          python - <<'PY'
          import os
          from datetime import datetime, timedelta
          import polars as pl

          os.makedirs('data/raw', exist_ok=True)

          def row(ts, dur_min, dist, fare, tip=0.0, extra=0.0, mta=0.5, tolls=0.0, impr=0.3, cong=2.5, airport=0.0, cbd=0.0,
                  vendor=1, pu=100, do=200, rate=1, pay=1, sflag='N'):
              t0 = datetime.fromisoformat(ts)
              t1 = t0 + timedelta(minutes=dur_min)
              total = fare + tip + extra + mta + tolls + impr + cong + airport + cbd
              return {
                  'tpep_pickup_datetime': t0.strftime('%Y-%m-%d %H:%M:%S'),
                  'tpep_dropoff_datetime': t1.strftime('%Y-%m-%d %H:%M:%S'),
                  'VendorID': vendor,
                  'PULocationID': pu,
                  'DOLocationID': do,
                  'payment_type': pay,
                  'passenger_count': 1,
                  'trip_distance': float(dist),
                  'fare_amount': float(fare),
                  'extra': float(extra),
                  'mta_tax': float(mta),
                  'tip_amount': float(tip),
                  'tolls_amount': float(tolls),
                  'improvement_surcharge': float(impr),
                  'congestion_surcharge': float(cong),
                  'airport_fee': float(airport),
                  'cbd_congestion_fee': float(cbd),
                  'total_amount': float(total),
                  'RatecodeID': rate,
                  'store_and_fwd_flag': sflag,
              }

          rows = [
              row('2024-01-05 08:00:00', 15, 3.2, 12.5, tip=3.0),
              row('2024-01-06 12:00:00',  8, 1.1,  7.0, tip=1.5, cong=0.0),
              row('2024-01-20 18:00:00', 30, 5.0, 18.0, tip=4.0, tolls=2.0),
          ]
          pl.DataFrame(rows).write_parquet('data/raw/yellow_tripdata_2024-01.parquet')
          print('Wrote sample raw file with', len(rows), 'rows')
          PY

      - name: Build Bronze
        run: python scripts/bronze_build.py --raw-dir data/raw --out data/bronze/bronze_trips.parquet

      - name: Build Silver
        run: python scripts/silver_split.py --bronze data/bronze/bronze_trips.parquet --outdir data/silver

      - name: dbt deps
        run: dbt deps

      - name: dbt seed + run
        run: |
          dbt seed
          dbt run

      - name: Bridge schemas for app queries
        run: |
          python - <<'PY'
          import duckdb, sys
          con = duckdb.connect('db/warehouse.duckdb')
          con.execute('CREATE SCHEMA IF NOT EXISTS main_marts;')
          con.execute('CREATE SCHEMA IF NOT EXISTS main_gold;')
          con.execute('CREATE SCHEMA IF NOT EXISTS main_main_gold;')

          def exists(schema: str, name: str) -> bool:
              q = """
              SELECT 1
              FROM information_schema.tables
              WHERE lower(table_schema)=? AND lower(table_name)=?
              LIMIT 1
              """
              return con.execute(q, [schema.lower(), name.lower()]).fetchone() is not None

          # Bridge marts.* -> main_marts.* when present
          marts = [
              'mart_kpi_daily', 'mart_payment_mix_daily', 'mart_vendor_scorecard_monthly',
              'mart_od_matrix_monthly', 'mart_adjustments_daily_zone', 'mart_airport_daily',
              'mart_anomaly_summary_daily', 'mart_congestion_impact_daily', 'mart_revenue_daily_zone',
              'mart_trips_hourly_vendor'
          ]
          for t in marts:
              if exists('marts', t):
                  con.execute(f'CREATE OR REPLACE VIEW main_marts.{t} AS SELECT * FROM marts.{t}')
              else:
                  print(f"[bridge] skip: marts.{t} does not exist")

          # Bridge gold -> main_gold; dim_date may live in main_gold already
          gold_views = ['fact_trips','fact_revenue_adjustments','dim_vendor','dim_payment','dim_zone']
          for t in gold_views:
              if exists('gold', t):
                  con.execute(f'CREATE OR REPLACE VIEW main_gold.{t} AS SELECT * FROM gold.{t}')
              else:
                  print(f"[bridge] skip: gold.{t} does not exist")

          # dim_date special-case: produced in schema main_gold per model config
          if exists('main_gold', 'dim_date'):
              pass
          elif exists('gold', 'dim_date'):
              con.execute('CREATE OR REPLACE VIEW main_gold.dim_date AS SELECT * FROM gold.dim_date')
          else:
              print('[bridge] skip: dim_date not found in gold or main_gold')

          # odd reference used in app for dim_date
          if exists('main_gold', 'dim_date'):
              con.execute('CREATE OR REPLACE VIEW main_main_gold.dim_date AS SELECT * FROM main_gold.dim_date')
          con.close()
          PY

      - name: Validate data for app
        run: |
          python - <<'PY'
          import duckdb, sys
          con = duckdb.connect('db/warehouse.duckdb', read_only=True)
          def check(sql, min_rows=1):
              n = con.execute(sql).fetchone()[0]
              print(sql, '->', n)
              assert n >= min_rows, f'Expected >= {min_rows} rows for: {sql}'
          try:
              check('SELECT COUNT(*) FROM main_marts.mart_kpi_daily')
              check('SELECT COUNT(*) FROM main_gold.fact_trips')
              check('SELECT COUNT(*) FROM main_main_gold.dim_date')
          except Exception as e:
              print('Validation failed:', e)
              sys.exit(1)
          con.close()
          PY

      - name: Install Playwright
        run: |
          pip install playwright
          python -m playwright install --with-deps chromium

      - name: Streamlit UI screenshots (all pages, 30 days)
        env:
          STREAMLIT_BROWSER_GATHER_USAGE_STATS: 'false'
        run: |
          bash -euxo pipefail -c '
            # Start Streamlit
            streamlit run app/execdashboard.py --server.headless true --server.port 8501 &
            PID=$!
            # Wait for server
            for i in $(seq 1 60); do
              if curl -fsS http://localhost:8501/ >/dev/null; then echo "Streamlit up"; break; fi
              sleep 1
            done

            # Drive UI via Playwright and take screenshots
            python - <<"PY"
            from playwright.sync_api import sync_playwright
            import time

            url = "http://localhost:8501"

            def set_window_30d(page):
                # Open the only combobox and choose Last 30 Days
                # Works with Streamlit's selectbox
                page.get_by_role("combobox").click()
                # Click the option by visible text
                page.get_by_text("Last 30 Days", exact=True).click()
                time.sleep(0.5)

            def go_radio(page, name):
                page.get_by_role("radio", name=name).click()
                time.sleep(0.8)

            with sync_playwright() as p:
                browser = p.chromium.launch()
                page = browser.new_page(viewport={"width": 1440, "height": 900})
                page.goto(url, wait_until="domcontentloaded", timeout=120_000)

                # Company Pulse
                set_window_30d(page)
                go_radio(page, "Company Pulse")
                page.screenshot(path="streamlit_company_pulse.png", full_page=True)

                # Strategic Levers
                go_radio(page, "Strategic Levers")
                page.screenshot(path="streamlit_strategic_levers.png", full_page=True)

                # Zone Heat
                go_radio(page, "Zone Heat")
                page.screenshot(path="streamlit_zone_heat.png", full_page=True)

                browser.close()
            PY

            kill $PID || true
          '

      - name: Upload screenshots
        uses: actions/upload-artifact@v4
        with:
          name: streamlit-screenshots
          path: |
            streamlit_company_pulse.png
            streamlit_strategic_levers.png
            streamlit_zone_heat.png
